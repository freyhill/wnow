
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="UTF-8">
					<meta name="viewport" content="width=device-width, initial-scale=1.0">
					<meta http-equiv="X-UA-Compatible" content="ie=edge">
					<title>放松放松</title>
					<link rel="stylesheet" href="../markdown.css">
				</head>
				<body>
				<section class="page-header" style='background-color: #92FFC0;background-image: linear-gradient(120deg, #92FFC0 , #002661);'>
				<h1 class="project-name">放松放松</h1>
				<h2 class="project-tagline">放松放松</h2>
					<a href="" class="btn">View on GitHub</a>
				</section>
				<div class='markdown-body' ><h1>webpack4+react16多页面架构</h1>
<p><img src="http://www.h5cool.com/webpack-react3.png" alt="webpack-react-multi-page"></p>
<p>webpack在单页面打包上应用广泛，以create-react-app为首的脚手架众多，单页面打包通常指的是将业务js，css打包到同一个html文件中，整个项目只有一个html文件入口,但也有<strong>许多业务需要多个页面不同的入口，比如不同的h5活动，或者需要支持seo的官方网站，都需要多个不同的html</strong>。<strong>webpack-react-multi-page</strong>架构让你可以在多页面在项目开发中<strong>自动化打包新创建页面并保证每个页面都可以热更新</strong> ，build打包后有清晰的文件层次结构。</p>
<h2>概览</h2>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td>webpack+react多页面架构</td>
</tr>
<tr>
<td>描述</td>
<td>简单易用的多页面自动化开发架构</td>
</tr>
<tr>
<td>开发者</td>
<td>leinov</td>
</tr>
<tr>
<td>发布日期</td>
<td>2018-11-07</td>
</tr>
<tr>
<td>版本</td>
<td>2.0</td>
</tr>
<tr>
<td>仓库</td>
<td><a href="https://github.com/leinov/webpack-react-multi-page">github地址</a></td>
</tr>
</tbody>
</table>
<h2>特性</h2>
<ul>
<li>👩‍👩‍👧‍👧 支持多页面同时热加载开发</li>
<li>📇 自动识别新创建页面</li>
<li>📝 每个页面生成个性化信息</li>
<li>🚻 分类打包</li>
<li>🔗 灵活扩展</li>
</ul>
<h2>安装&amp;使用</h2>
<pre><code>// clone
git clone git@github.com:leinov/webpack-react-multi-page.git

// 安装依赖包
npm install

// 开发
npm run dev

// 编译打包
npm run build

// 启动生产页面
npm start
</code></pre>
<p>新创建页面在src下添加文件夹并创建<code>pageinfo.json</code> 然后<code>npm run dev</code> 即可</p>
<pre><code>|-- src
    |-- index/
    |-- page2/
        |-- index.js
        |-- pageinfo.json
</code></pre>
<h2>项目架构</h2>
<h4>技术使用</h4>
<ul>
<li><code>react16</code></li>
<li><code>webpack4</code>
<ul>
<li><code>html-webpack-plugin 生成html文件</code></li>
<li><code>mini-css-extract-plugin css分离打包</code></li>
<li><code>uglifyjs-webpack-plugin js压缩</code></li>
<li><code>optimize-css-assets-webpack-plugin css压缩</code></li>
</ul>
</li>
<li><code>es6</code></li>
<li><code>babel</code></li>
<li><code>node</code>
<ul>
<li><code>opn 打开浏览器</code></li>
<li><code>compression 开启gzip压缩</code></li>
<li><code>express</code></li>
<li><code>fs</code></li>
</ul>
</li>
<li><code>git</code></li>
</ul>
<h4>目录结构</h4>
<pre><code>|-- webpack-react-multi-pages //项目
    |-- dist //编译生产目录
        |-- index
            |-- index.css
            |-- index.js
        |-- about
            |-- about.css
            |-- about.js
        |-- images
        |-- index.html
        |-- about.html
    |-- node_modules //node包
    |-- src //开发目录
        |-- index //index页面打包入口
            |-- images/
            |-- js
                |-- app.js// 业务js
            |-- index.sass
            |-- index.js //页面js入口
        |-- about //about页面打包入口
            |-- images/
                |--js
                    |-- app.js// 业务js
            |-- about.sass
            |-- about.js //页面js入口
        |-- template.html // html模板
        |-- style.sass //公共sass
    |-- webpackConfig //在webpack中使用
        |-- getEntry.js //获取入口
        |-- getFilepath.js //src下需要打包页面文件夹
        |-- htmlconfig.js //每个页面html注入数据
    |-- package.json
    |-- .gitignore
    |-- webpack.config.js //webpack配置文件
    |-- www.js //生产启动程序
</code></pre>
<h2>wiki</h2>
<h3>webpack打包单页面应用</h3>
<p>webpack在单页面打包上应用广泛，以create-react-app为首的接触脚手架众多，单页面打包通常指的是将业务js，css打包到同一个html文件中，整个项目只有一个html文件入口</p>
<h3>webpack单页面打包配置</h3>
<p>webpack.config.js</p>
<pre><code>module.exports = (env, argv) =&gt; ({
	entry: &quot;.src/index.js&quot;,
	output: {
		path: path.join(__dirname, &quot;dist&quot;),
		filename: &quot;bundle.js&quot;
	},
	module: {
		rules: [
		...
		],
	},
	plugins: [
	    new HtmlWebpackPlugin({
    		title: &quot;首页&quot;,
    		filename:&quot;index.html&quot;,
    		favicon:&quot;&quot;,
    		template: &quot;./src/template.html&quot;,

	    })
	]
});
</code></pre>
<p>这样就可以在<code>dist</code>文件夹下打包出一个下面这样的文件</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3>webpack多页面打包配置</h3>
<p>webpack 的entry支持两种种格式</p>
<h4>打包单个文件</h4>
<pre><code>module.exports = {
  entry: '.src/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }
};
</code></pre>
<p>这样就会在dist下打包出一个bundle.js</p>
<h4>打包出多个文件</h4>
<pre><code>module.exports = {
  entry: {
    index:&quot;./src/index.js&quot;,
    about:&quot;./src/about.js&quot;
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js' index.js,about.js这两个文件
  }
};
</code></pre>
<p>上面在dist下打包出两个与entry属性名对应的js文件</p>
<h4>将每个js挂载到相应的html文件上</h4>
<p>这里我们需要用到<code>html-webpack-plugin</code>这个webpack插件,每添加一个页面就需要在plugins添加一个<code>new HtmlWebpackPlugin({....})</code></p>
<pre><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = (env, argv) =&gt; ({
    entry: {
        index:&quot;./src/index.js&quot;,
        about:&quot;./src/about.js&quot;
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' index.js,about.js这两个文件
    }
    ....//其他配置
    plugins: [
        new HtmlWebpackPlugin(
            {
        		filename:&quot;index.html&quot;,//生成的index.html
        		template: &quot;./src/template.html&quot;,}) //模板
        		chunks:[&quot;index&quot;]
            }),
		new HtmlWebpackPlugin(
		    {
        		filename:&quot;about.html&quot;,//生成的index.html
        		template: &quot;./src/template.html&quot;,}) //模板
        		chunks:[&quot;index&quot;]
        	})
	]
})
</code></pre>
<p><code>html-webpack-plugin</code> 会通过 <code>template.html</code> 模板生成对应的filename名的html文件，并一并打包到output中对应的文件夹下，注意，在没有特殊配置的情况下所有打包的文件都是对应到output中 <code>path</code> 这个目录下，也包括html。这里的 <code>chunks</code> 需要注意，它是确定该html需要引入哪个js，如果没写的话，默认会引出所有打包的js，当然这不是我们想要的。</p>
<p>上面的配置最终可以在dist下打包出下面的文件结构</p>
<pre><code>|-- dist
    |-- index.js
    |-- about.js
    |-- index.html //内挂载index.js
    |-- about.html //内挂载about.js
</code></pre>
<p>通过上面这样的配置，再加上devServer，我们已经可以实现多页面的配置开发了，但这样很不智能，因为你每增加一个页面，就要在wepback里面配置一次，会非常繁琐，所以我们来优化下，让我们只专注于开发页面，配置交给webpack自己.</p>
<h3>webpack多页面配置优化</h3>
<p>我们再看下src下面的文件结构</p>
<pre><code>|-- src
    |-- index
        |-- app.js
        |-- index.scss
        |-- index.js
    |-- about
        |-- app.js
        |-- index.scss
        |-- index.js
</code></pre>
<p>src下面每个文件夹对应一个html页面的js业务，如果我们直接把文件夹对应入口js找到并把他们合并生成对应的entry，那是不是就不用手动写entry了呢，是的!</p>
<h4>遍历文件目录</h4>
<pre><code>/* eslint-env node */

/**
 * @file: getFilePath.js  遍历文件目录
 * @author: leinov
 * @date: 2018-10-11
 */

const fs = require(&quot;fs&quot;);

/**
 * 【遍历某文件下的文件目录】
 *
 * @param {String} path 路径
 * @returns {Array} [&quot;about&quot;,&quot;index&quot;]
 */
module.exports = function getFilePath(path){
	let fileArr = [];
	let existpath = fs.existsSync(path); //是否存在目录
	if(existpath){
		let readdirSync = fs.readdirSync(path);  //获取目录下所有文件
		readdirSync.map((item)=&gt;{
			let currentPath = path + &quot;/&quot; + item;
			let isDirector = fs.statSync(currentPath).isDirectory(); //判断是不是一个文件夹
			if(isDirector &amp;&amp; item !== &quot;component&quot;){ // component目录下为组件 需要排除
				fileArr.push(item);
			}
		});
		return fileArr;
	}
};
</code></pre>
<p>比如在src下有index页面项目，about项目 遍历结果为[&quot;index&quot;,&quot;about&quot;];</p>
<h4>遍历生成打包入口数组</h4>
<pre><code>/* eslint-env node */
/**
 * @file: getEntry.js 获取entry文件入口
 * @author: leinov
 * @date: 2018-10-11
 * @update: 2018-11-04 优化入口方法 调用getFilePath
 */
const getFilePath = require(&quot;./getFilepath&quot;);
/**
 * 【获取entry文件入口】
 *
 * @param {String} path 引入根路径
 * @returns {Object} 返回的entry { &quot;about/aoubt&quot;:&quot;./src/about/about.js&quot;,...}
 */
module.exports = function getEnty(path){
	let entry = {};
	getFilePath(path).map((item)=&gt;{
		/**
		 * 下面输出格式为{&quot;about/about&quot;:&quot;./src/aobout/index.js&quot;}
		 * 这样目的是为了将js打包到对应的文件夹下
		 */
		entry[`${item}/${item}`] = `${path}/${item}/index.js`;
	});
	return entry;
};
</code></pre>
<p>这里我们使用getFilepath获取的数组，在获取到每个目录下的js文件，组合成一个js入口文件的如下格式的对象。</p>
<pre><code>{
    &quot;index/index&quot;:&quot;./src/index/index.js&quot;,
    &quot;about/about&quot;:&quot;./src/about/index.js&quot;
}
</code></pre>
<h4>在webpack中使用getEntry</h4>
<pre><code>const getEntry = require(&quot;./webpackConfig/getEntry&quot;);
const entry = getEntry();

module.exports = (env, argv) =&gt; ({
	entry: entry,
})

</code></pre>
<p>这样我们就自动获取到了entry</p>
<h4>html-webpack-plugin自动配置</h4>
<p>因为每个页面都需要配置一个html，而且每个页面的标题，关键字，描述等信息可能不同，所以我们在每个页面文件夹下创建一个pageinfo.json,通过fs模块获取到json里信息再遍历到对应得html-webpack-plugin中生成一个html插件数组。</p>
<p><code>index/pageinfo.json</code>  生成<code>index.html</code>页面信息</p>
<pre><code>{
    &quot;title&quot;:&quot;首页&quot;,
     &quot;keywords&quot;:&quot;webpack多页面&quot;
}
</code></pre>
<p><code>about/pageinfo.json</code> 生成<code>about.html</code>页面信息供</p>
<pre><code>{
    &quot;title&quot;:&quot;关于页面&quot;,
    &quot;keywords&quot;:&quot;webpack多页面关于页面&quot;
}
</code></pre>
<p>通过fs遍历读取并生成HtmlWebpackPlugin数组供webpack使用</p>
<h4>遍历html插件数组</h4>
<pre><code>/**
 * @file htmlconfig.js  页面html配置
 * @author:leinov
 * @date: 2018-10-09
 * @update: 2018-11-05
 * @use: 动态配置html页面，获取src下每个文件下的pageinfo.json内容,解析到HtmlWebpackPlugin中
 */

const fs = require(&quot;fs&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);//生成html文件
const getFilePath = require(&quot;./getFilepath&quot;);
let htmlArr = [];

getFilePath(&quot;./src&quot;).map((item)=&gt;{
	let infoJson ={},infoData={};
	try{
		// 读取pageinfo.json文件内容，如果在页面目录下没有找到pageinfo.json 捕获异常
		infoJson = fs.readFileSync(`src/${item}/pageinfo.json`,&quot;utf-8&quot;);//
		infoData = JSON.parse(infoJson);
	}catch(err){
		infoData = {};
	}
	htmlArr.push(new HtmlWebpackPlugin({
		title:infoData.title ? infoData.title : &quot;webpack,react多页面架构&quot;,
		meta:{
			keywords: infoData.keywords ? infoData.keywords : &quot;webpack，react，github&quot;,
			description:infoData.description ? infoData.description : &quot;这是一个webpack，react多页面架构&quot;
		},
		chunks:[`${item}/${item}`], //引入的js
		template: &quot;./src/template.html&quot;,
		filename : item == &quot;index&quot; ? &quot;index.html&quot; : `${item}/index.html`, //html位置
		minify:{//压缩html
			collapseWhitespace: true,
			preserveLineBreaks: true
		},
	}));
});

module.exports = htmlArr;
</code></pre>
<h4>wbpack终极配置</h4>
<pre><code>const path = require(&quot;path&quot;);
const getEntry = require(&quot;./webpackConfig/getEntry&quot;); //入口配置
const entry = getEntry(&quot;./src&quot;);
const htmlArr =require(&quot;./webpackConfig/htmlConfig&quot;);// html配置

module.exports = (env, argv) =&gt; ({
    entry: entry
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
    }
    ....//其他配置
    devServer: {
	port: 3100,
	open: true,
    },
    plugins: [
        ...htmlArr
    ]
})
</code></pre>
<p>这样一个自动化完整的多页面架构配置就完成了，如果我们要新创建一个页面</p>
<ul>
<li>
<ol>
<li>在src下创建一个文件目录</li>
</ol>
</li>
<li>
<ol start="2">
<li>在新创建的文件目录下添加<code>index.js</code>（必须，因为是webpack打包入口文件）</li>
</ol>
</li>
<li>
<ol start="3">
<li>在新创建文件夹下添加<code>pageinfo.json</code>（非必须） 供html插件使用</li>
</ol>
</li>
<li>
<ol start="4">
<li><code>npm run dev</code>开发
完整代码参考项目<a href="https://github.com/leinov/webpack-react-multi-page">code</a></li>
</ol>
</li>
</ul>
<h2>版本</h2>
<table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">日期</th>
<th style="text-align:center">分支</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/leinov/webpack-react-multi-page">2.0</a></td>
<td style="text-align:center">2018-11-08</td>
<td style="text-align:center"><code>master</code></td>
<td style="text-align:center">优化html插件自动化</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/leinov/webpack-react-multi-page/tree/version1.0">1.0</a></td>
<td style="text-align:center">2018-10-07</td>
<td style="text-align:center"><code>version1.0</code></td>
<td style="text-align:center">第一版</td>
</tr>
</tbody>
</table>
</div>
				</body>
				</html>
			